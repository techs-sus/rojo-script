--!native
--!optimize 2

-- WARNING: This file is @generated by azalea. Do not edit.

--!generate TYPE_ID

--!generate CFRAME_ID_LOOKUP_TABLE
--!generate NewScript
--!generate NewLocalScript
--!generate NewModuleScript

local function decode(payloadBuffer: buffer)
	--!generate nilParentedInstance

	local loc = 0
	local VARIANT_DECODER: { [number]: () -> any }
	local nextVariant

	local function nextNullstring(): string
		local start = loc
		while true do
			loc += 1
			if buffer.readu8(payloadBuffer, loc) == 0 then
				-- ensure we skip null byte
				loc += 1
				break
			end
		end

		-- ensure we skip null byte in decoded string
		return buffer.readstring(payloadBuffer, start, loc - start - 1)
	end

	--!generate VARIANT_DECODER

	function nextVariant(expectedTypeIds: { number }?)
		-- 1. read type id
		-- 2. loc++;
		-- 3. call type id handler (which uses loc)

		local typeId = buffer.readu8(payloadBuffer, loc)
		loc += 1

		if expectedTypeIds and not table.find(expectedTypeIds, typeId) then
			error(`expected type id inside of array {table.concat(expectedTypeIds, ", ")}, got {typeId}`)
		end

		return assert(VARIANT_DECODER[typeId], "no variant decoder for type id " .. typeId)()
	end

	local rootReferent: string?
	local referentTree: { [string]: Instance } = {}

	-- late properties must be applied after the entire tree is decoded
	-- index signature: latePropertyMap[ref][propertyName] = propertyValue
	local latePropertiesMap: { [string]: { [string]: string } } = {}

	local function decodeInstance()
		local name: string = nextVariant({ TYPE_ID.String })
		local className: string = nextVariant({ TYPE_ID.String })
		local instanceReferent: string = nextVariant({ TYPE_ID.Ref })
		local parentReferent: string = nextVariant({ TYPE_ID.Ref, TYPE_ID.None })

		local propertiesLength = buffer.readu16(payloadBuffer, loc)
		local propertiesMap: { [string]: any } = {}
		loc += 2

		while propertiesLength > 0 do
			local propertyName = nextNullstring()

			local isTypeIdReferent = buffer.readu8(payloadBuffer, loc) == TYPE_ID.Ref
			if isTypeIdReferent then
				if not latePropertiesMap[instanceReferent] then
					latePropertiesMap[instanceReferent] = {}
				end

				latePropertiesMap[instanceReferent][propertyName] = nextVariant({ TYPE_ID.Ref })
			else
				propertiesMap[propertyName] = nextVariant()
			end

			-- print(propertyName)
			-- print(propertyName, propertiesMap[propertyName])

			propertiesLength -= 1
		end

		local instance: Instance
		--!generate SpecializedInstanceCreator
		referentTree[instanceReferent] = instance

		instance.Name = name

		if propertiesMap.Attributes then
			for attributeName, value in propertiesMap.Attributes do
				instance:SetAttribute(attributeName, value)
			end

			propertiesMap.Attributes = nil
		end

		if propertiesMap.Tags then
			for _, tag in propertiesMap.Tags do
				instance:AddTag(tag)
			end

			propertiesMap.Tags = nil
		end

		for propertyName, propertyValue in propertiesMap do
			-- TODO: add custom handlers
			local success, error = pcall(function()
				instance[propertyName] = propertyValue
			end)

			if not success then
				-- warn(`failed setting property {propertyName} with value {propertyValue}; got error {error}`)
			end
		end

		if parentReferent ~= nil then
			instance.Parent = referentTree[parentReferent]
		else
			assert(rootReferent == nil, "there are multiple root referents in the hierarchy")
			rootReferent = instanceReferent
		end

		return instanceReferent
	end

	-- decode entire buffer
	while true do
		local decodedReferent = decodeInstance()
		-- print(`decoded referent {decodedReferent}{if rootReferent == decodedReferent then " [root]" else ""}`)

		if buffer.len(payloadBuffer) == loc then
			-- print("finished decoding payloadBuffer")
			break
		end
	end
	assert(rootReferent, "no root referent in hierarchy")

	for referent, propertyMap in latePropertiesMap do
		-- late property handling (referent handling)
		for propertyName, propertyValue in propertyMap do
			local success, error = pcall(function()
				referentTree[referent][propertyName] = referentTree[propertyValue]
			end)

			if not success then
				warn(
					`failed setting late property {propertyName} on referent {referent} with value {propertyValue}; got error {error}`
				)
			end
		end
	end

	return referentTree[rootReferent]
end

return decode
